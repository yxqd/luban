#!/usr/bin/env python
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#
#                                 Jiao Lin
#                      California Institute of Technology
#                      (C) 2006-2009  All Rights Reserved
#
# {LicenseText}
#
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#


from luban.content import select, load, alert
import luban.content as lc

from luban.components.Actor import Actor as base
class Actor(base):

    class Inventory(base.Inventory):

        import pyre.inventory

        session_id = pyre.inventory.str('session_id')

        project_id = pyre.inventory.str('project_id')
        
        focus = pyre.inventory.str('focus')

        elementtype = pyre.inventory.str('elementtype')

        # this actually should not be here if gongshuzi is a real web app
        # but gongshuzi is actually a "desktop" app, so it is ok.
        outputdir = pyre.inventory.str('outputdir', default='../content/data/out/projects')

        # the original element that gets the event
        event_origin = pyre.inventory.str('event_origin')
        
        
    def default(self, director):
        # ignore session id, alwasy start a new one
        return self.createSession(director)


    def createSession(self, director):
        from gongshuzi.dom.Session import Session
        session = director.clerk.insertNewOwnedRecord(Session)

        self.inventory.session_id = session.id

        return self.startSession(director)


    def startSession(self, director):
        '''start session by asking user to select
        a project or create a new project
        '''
        # assume when session started, project is not selected
        return self.askForProject(director)


    def askForProject(self, director):
        frame = lc.frame(title=default_title)
        
        skeleton = director.retrieveVisual('skeleton')
        frame.add(skeleton)

        # turn off some menus and menu items
        menubar = skeleton.find(id='menubar')
        projectmenu = skeleton.find(id='projectmenu')
        projectmenu.find(id='menuitem_projectsavefiles').hidden = True
        projectmenu.find(id='menuitem_projectserve').hidden = True
        projectmenu.find(id='menuitem_projectrun').hidden = True
        projectmenu.find(id='menuitem_projectdelete').hidden = True
        menubar.find(id='visualmenu').hidden = True
        menubar.find(id='actormenu').hidden = True
        
        #
        mainarea = skeleton.find('mainarea-frame')
        mainarea.add(director.retrieveVisual('ask-for-project'))
        
        return frame


    def presentNewProjectForm(self, director):
        doc = lc.document(id='new-project-frame')

        project = self._getProject(director)
        if project:
            link = lc.link(
                label='Back to project "%s"' % project.projectname,
                onclick = load(
                    actor='gongshuzi',
                    routine='loadProject',
                    session_id = self.inventory.session_id,
                    project_id = project.id,
                    )
                )
            doc.add(link)
            
        form = director.retrieveVisual('newproject-form')
        doc.add(form)
        
        actions = [
            select(id='mainarea-frame').replaceContent(doc),
            select(id='').setAttr(title=default_title),
            ]
        
        # menubar
        hidemenus = [
            select(id='menuitem_projectsavefiles').hide(),
            select(id='menuitem_projectserve').hide(),
            select(id='menuitem_projectrun').hide(),
            select(id='menuitem_projectdelete').hide(),
            select(id='visualmenu').hide(),
            select(id='actormenu').hide(),
            ]
        actions += hidemenus

        return actions


    def presentExistingProjectsForSelectionToOpen(self, director):
        doc = lc.document(id='project-selection-frame')

        project = self._getProject(director)
        if project:
            link = lc.link(
                label='Back to project "%s"' % project.projectname,
                onclick = load(
                    actor='gongshuzi',
                    routine='loadProject',
                    session_id = self.inventory.session_id,
                    project_id = project.id,
                    )
                )
            doc.add(link)
            
        visual = director.retrieveVisual('project-selection')
        doc.add(visual)
        
        actions = [
            select(id='mainarea-frame').replaceContent(doc),
            select(id='').setAttr(title=default_title),
            ]
    
        # menubar
        hidemenus = [
            select(id='menuitem_projectsavefiles').hide(),
            select(id='menuitem_projectserve').hide(),
            select(id='menuitem_projectrun').hide(),
            select(id='menuitem_projectdelete').hide(),
            select(id='visualmenu').hide(),
            select(id='actormenu').hide(),
            ]
        actions += hidemenus

        return actions


    def saveToFiles(self, director):
        project = self._getProject(director)
        settings = self._getSettings(director)

        project = director.clerk.orm.record2object(project, recursive=1, db=director.clerk.db)
        project.port = settings.port

        from gongshuzi.utils.project2fs import project2fs
        import os
        outdir = os.path.abspath(self.inventory.outputdir)
        project2fs(project, root=outdir, overwrite=True, visual_output_type='funcs')

        return
        return alert('Project "%s" was saved to %s' % (project.name, outdir))


    def serveProject(self, director):
        self.saveToFiles(director)

        # try connect and see if the site is already alive
        status = self._checkProjectServeStatus(director)

        settings = self._getSettings(director)
        if status == 'alive':
            return alert('http://localhost:%s already taken. already served?' % settings.port)

        try:
            self._startProjectServer(director)
        except Exception, error:
            import traceback
            return alert('%s' % traceback.format_exc())
        
        text = director.painter._createProjectServeStatusIndicator('alive', settings.port)
        elem = select(id='projectstatus')
        return elem.setAttr(text = text)


    def runProject(self, director):
        self.saveToFiles(director)

        try:
            self._runProject(director)
        except Exception, error:
            import traceback
            return alert('%s' % traceback.format_exc())
        return


    def deleteProject(self, director):
        project = self._getProject(director)
        settings = self._getSettings(director)
        director.clerk.deleteRecordWithID(settings)
        director.clerk.deleteRecordWithID(project)

        mainarea = select(id='mainarea-frame')
        return mainarea.replaceContent(director.retrieveVisual('ask-for-project'))
        

    def _checkProjectServeStatus(self, director):
        # try connect and see if the site is already alive
        settings = self._getSettings(director)
        #
        port = settings.port
        #
        import httplib
        c = httplib.HTTPConnection('localhost', port)
        try: c.connect()
        except:
            return 
        else:
            return 'alive'
        

    def _startProjectServer(self, director):
        project = self._getProject(director)
        settings = self._getSettings(director)
        port = settings.port
        # check if port is unique
        from gongshuzi.components.ProjectServing import getAllPortsUsedExceptMine, findUniquePort
        ports = getAllPortsUsedExceptMine(director.clerk.db, settings)
        if port in ports:
            try:
                suggestion = findUniquePort(director.clerk.db, settings)
            except:
                suggestion = None
            msg = 'Port %s is not a unqiue one.'
            if suggestion: msg += ' Suggest port number: %s' % suggestion
            return alert(msg)
                
        #
        # serve
        import os
        path = os.path.abspath(os.path.join(
            self.inventory.outputdir,
            project.projectname,
            'html'))
        cmds = [
            'cd %s && SimpleHttpServer.py -SimpleHttpServer.port=%s > /dev/null' % (path, port),
            ]
        cmd = ' && '.join(cmds)
        if os.system(cmd):
            msg = 'failed to serve. cmd: %s' % cmd
            raise RuntimeError, msg
        return
        

    def _runProject(self, director):
        project = self._getProject(director)

        import os
        path = os.path.abspath(os.path.join(
            self.inventory.outputdir,
            project.projectname,
            'bin'))
        cmds = [
            'spawn-daemon.py -home=%s -cmd="wxmain.py"' % (path, ),
            ]
        cmd = ' && '.join(cmds)
        if os.system(cmd):
            msg = 'failed to run. cmd: %s' % cmd
            raise RuntimeError, msg
        return
        

    def loadProject(self, director):
        # when loading a project, session data need to be cleared
        session = self._getSession(director)
        session.categoryselection = 'visuals'
        session.current_visual = ''
        session.current_actor = ''
        session.current_document = ''

        # assign a default actor
        project = self._getProject(director)
        db = director.clerk.db
        actors = project.actors.dereference(db)
        if actors:
            name, actor = actors[0]
            session.current_actor = actor
        
        director.clerk.updateRecordWithID(session)

        return self._loadProject(director)


    def _loadProject(self, director):
        projecteditorframe = director.retrieveVisual('project-editor-frame')

        # session
        session = self._getSession(director)
        
        # project
        project = self._getProject(director)

        # current visual
        thevisual = self._getCurrentVisual(director)
        # current actor
        theactor = self._getCurrentActor(director)
        
        # visuals
        visuals_ref = project.visuals
        visuals = visuals_ref.dereference(director.clerk.db)

        # container element of visuals
        visualscontainer = projecteditorframe.find(id='visualscontainer')
        visualscontainer.selected = (session.categoryselection == 'visuals')

        # accordion for visuals
        visualsroot = lc.accordion(id='accordion-visuals')
        visualsroot.onchange = select(element=visualsroot).notify(
            event = 'changed',
            actor='visual', routine='switch',
            session_id = self.inventory.session_id,
            )
        visualscontainer.add(visualsroot)
        
        for name, visual in visuals:
            visualsection = visualsroot.section(label=visual.visualname)
            visualsection.id=director.painter._elementid(visualsection, visual)

            if thevisual:
                if visual.id == thevisual.id:
                    visualsection.selected = True
            
            treeview = director.painter._createTreeView(
                visual, director.clerk,
                session_id = self.inventory.session_id)
            if treeview:
                visualsection.add(treeview)
            continue

        # actors
        actors_ref = project.actors
        actors = actors_ref.dereference(director.clerk.db)

        # container element of actors
        actorscontainer = projecteditorframe.find(id='actorscontainer')
        actorscontainer.selected = (session.categoryselection == 'actors')
        # present the list of actors
        actorlistview = director.painter._createActorList(
            [a for n,a in actors], session.id,
            selected = theactor)
        actorscontainer.add(actorlistview)

        # set up the preview
        preview = None
        if session.categoryselection == 'visuals' and thevisual:
            preview = director.painter._createPreviewForVisual(
                thevisual, director.clerk,
                session_id = self.inventory.session_id)
        elif session.categoryselection == 'actors' and theactor:
            preview = director.painter._createPreviewForActor(
                theactor, director.clerk,
                session_id = self.inventory.session_id)
        if preview:
            projecteditorframe.find(id='previewcontainer').add(preview)
        
        # set up the property editor
        if session.categoryselection == 'visuals' and thevisual:
            proptable = director.painter._createPropertyTable(
                director.clerk.orm.record2object(thevisual),
                record_id = thevisual.id,
                session_id = self.inventory.session_id)
        elif session.categoryselection == 'actors' and theactor:
            proptable = director.painter._createPropertyTable(
                director.clerk.orm.record2object(theactor),
                record_id = theactor.id,
                session_id = self.inventory.session_id,
                excludes=['content'],
                )
        else:
            proptable = director.retrieveVisual('propertytable')

        projecteditorframe.find(id='propertyeditor').add(proptable)

        # project settings editor
        settings = self._getSettings(director)
        settingstable = director.painter._createProjectSettingsTable(session, project, settings)
        projecteditorframe.find(id='projectsettings').add(settingstable)

        actions = [
            select(id='mainarea-frame').replaceContent(projecteditorframe),
            select(id='').setAttr(title=titleForProjectEditor(project)),
            ]

        # project status
        status = self._checkProjectServeStatus(director)
        statuselem = projecteditorframe.find(id='projectstatus')
        settings = self._getSettings(director)
        statuselem.text = director.painter._createProjectServeStatusIndicator(
            status, settings.port)

        # menubar
        showmenus = [
            select(id='menuitem_projectsavefiles').show(),
            select(id='menuitem_projectserve').show(),
            select(id='menuitem_projectrun').show(),
            select(id='menuitem_projectdelete').show(),
            select(id='visualmenu').show(),
            select(id='actormenu').show(),
            ]
        actions += showmenus
        
        # widgetpalette
##         if session.categoryselection == 'actors':
##             actions.append(select(id='widgetpalette').hide())
##         else:
##             actions.append(select(id='widgetpalette').show())

        return actions


    def switchVisual(self, director):
        session = self._getSession(director)
        assert session.categoryselection == 'visuals'

        focus = self.inventory.focus
        assert focus.startswith('visuals')
        
        thevisual = director.clerk.db.dereference(focus)
        visualinstance = thevisual.visualinstance
        
        session.current_visual = thevisual

        # don't focus on any document
        current_document = session.current_document = ''
        director.clerk.updateRecordWithID(session)

        actions = []
        # treeview
        treeviewid = director.painter._treeviewid(thevisual)
        # branchid = director.painter._treeviewnodeid(current_document)
        # actions.append(
        #   select(id=treeviewid).treeview('select', node=branchid)
        #    )

        # preview
        if visualinstance and visualinstance.id:
            preview = director.painter._createPreviewForVisual(
                thevisual, director.clerk,
                session_id = self.inventory.session_id,
                )
            previewupdate = select(id='previewcontainer').replaceContent(preview)
        else:
            previewupdate = select(id='previewcontainer').empty()
        actions.append(previewupdate)
            
        # property editor
        focus = thevisual
        proptable = director.painter._createPropertyTable(
            director.clerk.orm.record2object(focus),
            record_id = focus.id,
            session_id = self.inventory.session_id)
        updatepropeditor = select(id='propertyeditor').replaceContent(proptable)
        
        actions.append(updatepropeditor)

        return actions


    def switchActor(self, director):
        session = self._getSession(director)
        assert session.categoryselection == 'actors'

        focus = self.inventory.focus
        assert focus.startswith('actors')
        
        theactor = director.clerk.db.dereference(focus)
        session.current_actor = theactor
        director.clerk.updateRecordWithID(session)

        actions = []
        # actor list view
        # code editor
        codeeditorupddate = select(id='previewcontainer').replaceContent(
            director.painter._createActorEditor(theactor, session.id)
            )
        actions.append(codeeditorupddate)
            
        # property editor
        focus = theactor
        proptable = director.painter._createPropertyTable(
            director.clerk.orm.record2object(focus),
            record_id = focus.id,
            session_id = self.inventory.session_id,
            excludes=['content'],
            )
        updatepropeditor = select(id='propertyeditor').replaceContent(proptable)
        
        actions.append(updatepropeditor)

        return actions


    def handlePropertyChange(self, director):
        # property change is actually first handled by propertyeditor
        # then here we need to do some additional response.
        
        # this is a hack. see propertyeditor.processUpdate
        property, value = director.propertyChange

        focus = self._getFocus(director)

        if focus.name == 'visuals':
            if property == 'visualname':
                return select(id=director.painter._accordionsectionid(focus)).setAttr(label=value)
            return

        if focus.name == 'actors':
            if property == 'actorname':
                theactor = self._getCurrentActor(director)
                newcontent = _changeActorName(
                    theactor.content, director.propertyOldValue, value)
                theactor.content = newcontent
                director.clerk.updateRecordWithID(theactor)
                return self._loadProject(director)

        # ui element
        # Class needs special attention
        if property == 'Class':
            value = value + ' preview selected'
        attrs = {property: value}
        return select(id=director.painter._previewid(focus)).setAttr(**attrs)


    def newVisual(self, director):
        session = self._getSession(director)
        if session.categoryselection != 'visuals': return

        project = self._getProject(director)
        visual = self._newVisual(project, director)
        
        session.current_visual = visual
        session.current_document = ''
        director.clerk.updateRecordWithID(session)

        # actions
        #  accordion
        actions = [
            # add a new section to the accordion
            select(id='accordion-visuals').accordion(
                'createSection',
                id=director.painter._accordionsectionid(visual),
                label = visual.visualname,
            )]

        #  treeview in accordion section
        treeview = director.painter._createTreeView(
            visual, director.clerk,
            session_id = self.inventory.session_id)
        if treeview: actions.append(
            select(id=director.painter._accordionsectionid(visual)).append(treeview)
            )

        #  new visual don't need preview. skip

        #  property table for visual
        proptable = director.painter._createPropertyTable(
            director.clerk.orm.record2object(visual),
            record_id = visual.id,
            session_id = self.inventory.session_id)
        if proptable:
            actions.append(
                select(id='propertyeditor').replaceContent(proptable)
                )
        return actions
    

    def deleteVisual(self, director):
        session = self._getSession(director)
        if session.categoryselection != 'visuals': return
        
        project = self._getProject(director)
        
        db = director.clerk.db
        current_visual = session.current_visual.dereference(db)
        
        project.visuals.delete(current_visual, db)

        return self.loadProject(director)


    def newActor(self, director):
        session = self._getSession(director)
        if session.categoryselection != 'actors': return

        project = self._getProject(director)
        actor = self._newActor(project, director)

        oldactor = session.current_actor.dereference(director.clerk.db)
        session.current_actor = actor
        director.clerk.updateRecordWithID(session)

        # actions
        #  actor list
        actions = [
            # add the new actor to the actor list
            select(id='actor-list').append(
            director.painter._createActorItemInActorList(actor, session.id, selected=True)
            ),
            ]

        #  editor
        actions.append(select(id='previewcontainer').replaceContent(
            director.painter._createActorEditor(actor, session.id)
            ))

        #  property table for actor
        proptable = director.painter._createPropertyTable(
            director.clerk.orm.record2object(actor),
            record_id = actor.id,
            session_id = self.inventory.session_id,
            excludes = ['content'],
            )
        if proptable:
            actions.append(
                select(id='propertyeditor').replaceContent(proptable)
                )

        # deselect the old actor
        if oldactor:
            actions.append(
                select(id=director.painter._actoritemid(oldactor)).setAttr(selected=False)
                )
        return actions


    def deleteActor(self, director):
        session = self._getSession(director)
        if session.categoryselection != 'actors': return
        
        project = self._getProject(director)
        
        db = director.clerk.db
        current_actor = session.current_actor.dereference(db)
        
        project.actors.delete(current_actor, db)

        actors = project.actors.dereference(db)
        if len(actors):
            # select the first actor
            name, actor = actors[0]
            session.current_actor = actor
            director.clerk.updateRecordWithID(session)

        return self._loadProject(director)


    def switchTovisuals(self, director):
        session = self._getSession(director)
        categoryselection = session.categoryselection

        if categoryselection == 'visuals':
            # nothing need to do
            return

        session.categoryselection = 'visuals'
        director.clerk.updateRecordWithID(session)

        return self._loadProject(director)


    def switchToactors(self, director):
        session = self._getSession(director)
        categoryselection = session.categoryselection

        if categoryselection == 'actors':
            # nothing need to do
            return

        session.categoryselection = 'actors'
        director.clerk.updateRecordWithID(session)

        return self._loadProject(director)


    def newElement(self, director):
        session = self._getSession(director)
        if session.categoryselection != 'visuals':
            return
        
        visual = self._getCurrentVisual(director)
        if not visual:
            return alert('Please select a visual')

        # db table name of selected element
        tablename = self.inventory.elementtype

        # if there is a special handler, use it
        handler = '_newElement_%s' % tablename
        if hasattr(self, handler):
            handler = getattr(self, handler)
            return handler(director)
        
        # db table of selectedd element
        elementtable = director.clerk._getTable(tablename)

        # the luban ui element type
        elementtype = director.clerk.orm.getObject(elementtable)

        # current document
        document = self._getCurrentDocument(director)
        if not document:
            # no current document, this is the root element
            # for the current visual.

            # some elements cannot be root
            from luban.content.ElementNotRoot import ElementNotRoot
            if issubclass(elementtype, ElementNotRoot):
                return alert('This element type %r cannot be root element' % elementtype.__name__)
            newelement = director.clerk.insertNewOwnedRecord(tablename)
            
            visual.visualinstance = newelement
            director.clerk.updateRecordWithID(visual)

        else:
            documenttype = director.clerk.orm.getObject(document.__class__)
            # append new element to the current document
            # !!! frame must be root
            if tablename == 'frames':
                return alert('frame has to be the root element')
            # some elements cannot be children of this parent node
            p = documenttype()
            e = elementtype()
            try:
                p.add(e)
            except Exception, e:
                return alert(str(e))
            del p,e
            
            newelement = director.clerk.insertNewOwnedRecord(tablename)
            document.contents.add(newelement, director.clerk.db)

        # update session's current_document pointer
        session.current_document = newelement
        director.clerk.updateRecordWithID(session)

        # update views
        return self._updateViewsForAVisualUponNewElement(
            director,
            visual, newelement, container=document)


    def _updateViewsForAVisualUponNewElement(
        self, director,
        visual, newelement, container=None):

        if container is None:
            previewcontainer_id = 'previewcontainer'
        else:
            previewcontainer_id = director.painter._previewid(container)

        # actions
        actions = []
        # - update treeview
        # *******************************************************************
        # The following update does not work consistently. The jstree is not
        # working as expected. 
        #   treeviewupdate
        # from luban.content.TreeView import TreeViewBranch
        # newbranch = TreeViewBranch(**director.painter._treeviewNodeParams(newelement))
        # treeviewid = director.painter._treeviewid(visual)
        # if document:
        #     treeviewupdate = select(id=treeviewid).addTreeViewBranch(
        #         referencenode = director.painter._treeviewnodeid(document),
        #         newnode = newbranch,
        #         )
        # else: 
        #     treeviewupdate = select(id=treeviewid).setTreeViewRoot(newbranch)
        # *******************************************************************
        treeviewid = director.painter._treeviewid(visual)
        treeviewupdate = [
            select(id=treeviewid).destroy(),
            select(id=director.painter._accordionsectionid(visual)).append(
                director.painter._createTreeView(
                    visual, director.clerk,
                    session_id = self.inventory.session_id)
                )
            ]
        actions += treeviewupdate
        # select the new element
        treeviewbranchid = director.painter._treeviewnodeid(newelement)
        selectnewelement = select(id = treeviewid).treeview(
            'select', node=treeviewbranchid)
        
        # - create the new element's visual representation
        newelementpreview = director.painter._createPreviewForElement(
            newelement, director.clerk, selected=1,
            session_id = self.inventory.session_id)
        addpreview = select(id=previewcontainer_id).append(newelementpreview)
        actions.append(addpreview)
        # - deselect the older focus
        if container:
            deselect_previous_focus = select(
                id=previewcontainer_id).removeClass('selected')
            actions.append(deselect_previous_focus)

        # - update property editor
        proptable = director.painter._createPropertyTable(
            director.clerk.orm.record2object(newelement),
            record_id = newelement.id,
            session_id = self.inventory.session_id,
            )
        propeditorupdate = select(id='propertyeditor').replaceContent(proptable)
        actions.append(propeditorupdate)

        # ???
        # select new element at the treeview must be the last action
        # because it will trigger a switch-element event
        actions.append(selectnewelement)
        return actions


    def _newElement_tabss(self, director):
        session = self._getSession(director)
        visual = self._getCurrentVisual(director)
        # current document
        document = self._getCurrentDocument(director)
        if not document:
            # create tabs
            newelement = tabs = self._createTabs(director)
            
            # root node
            visual.visualinstance = tabs
            director.clerk.updateRecordWithID(visual)

        else:
            # if parent is tabs, we are actually adding new tab
            if document.name == 'tabss':
                tablename = 'tabs'
                newelement = director.clerk.insertNewOwnedRecord(tablename)
            else:
                tablename = 'tabss'
                newelement = self._createTabs(director)
            document.contents.add(newelement, director.clerk.db)

        return self._loadProject(director) + [
            load(actor=self.name, routine='switchElement',
                 session_id = self.inventory.session_id,
                 project_id = self.inventory.project_id,
                 focus = refStrFromRecord(newelement),
                 ),
            ]


    def _createTabs(self, director):
        tabs = director.clerk.insertNewOwnedRecord('tabss')
        # add two tabs
        tab1 = director.clerk.insertNewOwnedRecord('tabs')
        tabs.contents.add(tab1, director.clerk.db)
        tab2 = director.clerk.insertNewOwnedRecord('tabs')
        tabs.contents.add(tab2, director.clerk.db)
        return tabs


    def _newElement_accordions(self, director):
        session = self._getSession(director)
        visual = self._getCurrentVisual(director)
        # current document
        document = self._getCurrentDocument(director)
        if not document:
            # create accordion
            newelement = accordion = self._createAccordion(director)
            
            # root node
            visual.visualinstance = accordion
            director.clerk.updateRecordWithID(visual)

        else:
            # if parent is accordion, we are actually adding new section
            if document.name == 'accordions':
                tablename = 'accordionsections'
                newelement = director.clerk.insertNewOwnedRecord(tablename)
                newelement.label = 'new section'
                director.clerk.updateRecordWithID(newelement)
            else:
                tablename = 'accordions'
                newelement = self._createAccordion(director)
            document.contents.add(newelement, director.clerk.db)

        return self._loadProject(director) + [
            load(actor=self.name, routine='switchElement',
                 session_id = self.inventory.session_id,
                 project_id = self.inventory.project_id,
                 focus = refStrFromRecord(newelement),
                 ),
            ]


    def _createAccordion(self, director):
        accordion = director.clerk.insertNewOwnedRecord('accordions')
        # add two sections
        section1 = director.clerk.insertNewOwnedRecord('accordionsections')
        section1.label = 'section1'
        director.clerk.updateRecordWithID(section1)
        accordion.contents.add(section1, director.clerk.db)
        
        section2 = director.clerk.insertNewOwnedRecord('accordionsections')
        section2.label = 'section2'
        director.clerk.updateRecordWithID(section2)
        accordion.contents.add(section2, director.clerk.db)
        return accordion


    def _newElement_splitters(self, director):
        session = self._getSession(director)
        visual = self._getCurrentVisual(director)
        # current document
        document = self._getCurrentDocument(director)
        if not document:
            # create splitter
            newelement = splitter = self._createSplitter(director)
            
            # root node
            visual.visualinstance = splitter
            director.clerk.updateRecordWithID(visual)

        else:
            # if parent is splitter, we are actually adding new section
            if document.name == 'splitters':
                tablename = 'splitsections'
                newelement = director.clerk.insertNewOwnedRecord(tablename)
            else:
                newelement = self._createSplitter(director)
            document.contents.add(newelement, director.clerk.db)
            
        return self._loadProject(director) + [
            load(actor=self.name, routine='switchElement',
                 session_id = self.inventory.session_id,
                 project_id = self.inventory.project_id,
                 focus = refStrFromRecord(newelement),
                 ),
            ]


    def _createSplitter(self, director):
        container = director.clerk.insertNewOwnedRecord('splitters')
        # add two splitter sections
        section1 = director.clerk.insertNewOwnedRecord('splitsections')
        container.contents.add(section1, director.clerk.db)
        section2 = director.clerk.insertNewOwnedRecord('splitsections')
        container.contents.add(section2, director.clerk.db)
        return container


    def _newElement_portlets(self, director):
        session = self._getSession(director)
        visual = self._getCurrentVisual(director)
        # current document
        document = self._getCurrentDocument(director)
        if not document:
            # create portlet
            newelement = portlet = self._createPortlet(director)
            
            # root node
            visual.visualinstance = portlet
            director.clerk.updateRecordWithID(visual)

        else:
            # if parent is portlet, we are actually adding new item
            if document.name == 'portlets':
                tablename = 'portletitems'
                newelement = director.clerk.insertNewOwnedRecord(tablename)
                newelement.label = 'newitem'
                director.clerk.updateRecordWithID(newelement)
            else:
                newelement = self._createPortlet(director)
            document.contents.add(newelement, director.clerk.db)
            
        return self._loadProject(director) + [
            load(actor=self.name, routine='switchElement',
                 session_id = self.inventory.session_id,
                 project_id = self.inventory.project_id,
                 focus = refStrFromRecord(newelement),
                 ),
            ]


    def _createPortlet(self, director):
        container = director.clerk.insertNewOwnedRecord('portlets')
        container.label = 'newportlet'
        director.clerk.updateRecordWithID(container)
        
        # add two portlet items
        item1 = director.clerk.insertNewOwnedRecord('portletitems')
        item1.label = 'item1'
        director.clerk.updateRecordWithID(item1)
        container.contents.add(item1, director.clerk.db)
        
        item2 = director.clerk.insertNewOwnedRecord('portletitems')
        item2.label = 'item2'
        director.clerk.updateRecordWithID(item2)
        container.contents.add(item2, director.clerk.db)
        return container


    def switchElement(self, director):
        session = self._getSession(director)
        thevisual = self._getCurrentVisual(director)

        olddoc = self._getCurrentDocument(director)

        session.current_document = self.inventory.focus
        director.clerk.updateRecordWithID(session)
        current_document = session.current_document.dereference(director.clerk.db)

        # actions
        actions = []

        # update treeview
        if self.inventory.event_origin != 'treeview':
            updatetreeview = select(id=director.painter._treeviewid(thevisual)).treeview(
                'select', node = director.painter._treeviewnodeid(current_document) )
            actions.append(updatetreeview)
        
        # update property editor
        proptable = director.painter._createPropertyTable(
            director.clerk.orm.record2object(current_document),
            record_id = current_document.id,
            session_id = self.inventory.session_id,
            )
        propeditorupdate = select(id='propertyeditor').replaceContent(proptable)
        actions.append(propeditorupdate)
        
        # preview update
        previewupdate = []
        if olddoc:
            deselect = select(id=director.painter._previewid(olddoc)) \
                       .removeClass('selected')
            previewupdate.append(deselect)
        previewupdate.append(
            select(id=director.painter._previewid(current_document))\
            .addClass('selected')
            )
        actions += previewupdate
        
        return actions


    def delete(self, director):
        focus = self._getFocus(director)
        if focus.name == 'visuals': return self.deleteVisual(director)
        if focus.name == 'actors': return self.deleteActor(director)
        return self.deleteElement(director)


    def deleteElement(self, director):
        session = self._getSession(director)

        # the thing to remove
        current_document = self._getCurrentDocument(director)
        if not current_document: return

        # 
        visual = self._getCurrentVisual(director)

        # find the parent element
        parent = director.clerk.findParentDocument(current_document, visual)
        if not parent:
            assert current_document.id == visual.visualinstance.id
            isroot = True
        else:
            isroot = False

        # actions
        actions = []
        
        # preview
        deletepreview = select(id=director.painter._previewid(current_document)).destroy()
        actions.append(deletepreview)
        
        # treeview
        treeviewid = director.painter._treeviewid(visual)
        updatetreeview = select(id=treeviewid).removeTreeViewNode(
            node=director.painter._treeviewnodeid(current_document)
            )
        actions.append(updatetreeview)
        if not isroot:
            selectparent = select(id=treeviewid).treeview(
                'select', node = director.painter._treeviewnodeid(parent))
            actions.append(selectparent)
            
        # propeditor
        if isroot:
            proptable = director.painter._createPropertyTable(
                director.clerk.orm.record2object(visual),
                record_id = visual.id,
                session_id = self.inventory.session_id,
                )
        else:
            proptable = director.painter._createPropertyTable(
                director.clerk.orm.record2object(parent),
                record_id = parent.id,
                session_id = self.inventory.session_id,
                )
            
        updatepropeditor = select(id='propertyeditor').replaceContent(proptable)
        actions.append(updatepropeditor)

        # remove the element from container
        if isroot:
            visual.visualinstance = ''
            director.clerk.updateRecordWithID(visual)
        else:
            parent.contents.delete(current_document, director.clerk.db)

        # update the session
        if isroot:
            session.current_document = ''
        else:
            session.current_document = parent
        director.clerk.updateRecordWithID(session)
        return actions
        

    # helpers

    # dom manipulations
    def _newVisual(self, project, director):
        visual = director.clerk.insertNewOwnedRecord('visuals')
        visual.visualname = 'visual'+visual.id
        director.clerk.updateRecordWithID(visual)
        visualname = visual.visualname
        project.visuals.add(visual, director.clerk.db, name=visualname)
        return visual


    def _newActor(self, project, director):
        actor = director.clerk.insertNewOwnedRecord('actors')
        actor.actorname = 'actor'+actor.id
        actor.content = _actorTemplate(actor.actorname)
        director.clerk.updateRecordWithID(actor)
        actorname = actor.actorname
        project.actors.add(actor, director.clerk.db, name=actorname)
        return actor


    def _getSession(self, director):
        # session
        session_id = self.inventory.session_id
        if not session_id:
            return None
        session = director.clerk.getRecordByID('sessions', session_id)
        return session


    def _getSettings(self, director):
        project = self._getProject(director)
        if project is None: raise
        settingslist = director.clerk.db.dereference(project.settings)
        assert len(settingslist) < 2
        if not settingslist:
            # create one
            from gongshuzi.dom.ProjectSettings import ProjectSettings
            settings = director.clerk.insertNewOwnedRecord(ProjectSettings)
            settings.project = project
            director.clerk.updateRecordWithID(settings)
            # find a unique port
            from gongshuzi.components.ProjectServing import findUniquePort
            port = findUniquePort(director.clerk.db, settings)
            settings.port = port
            director.clerk.updateRecordWithID(settings)
        else:
            settings = settingslist[0]
        return settings


    def _getProject(self, director):
        session = self._getSession(director)
        if session is None: return
        
        project_id = self.inventory.project_id
        if project_id:
            session.project = project_id
            director.clerk.updateRecordWithID(session)
            
        project_ref = session.project
        if not project_ref or not project_ref.id:
            return None
            
        return project_ref.dereference(director.clerk.db)


    def _getCurrentVisual(self, director):
        session = self._getSession(director)
        current_visual = session.current_visual
        if not current_visual or not current_visual.id:
            project = self._getProject(director)
            visuals = project.visuals.dereference(director.clerk.db)
            if visuals:
                current_visual = visuals[0][1] # name, instance
                session.current_visual = current_visual
                director.clerk.updateRecordWithID(session)
                return current_visual
            return
        return current_visual.dereference(director.clerk.db)


    def _getCurrentActor(self, director):
        session = self._getSession(director)
        current_actor = session.current_actor
        if not current_actor or not current_actor.id: return
        return current_actor.dereference(director.clerk.db)


    def _getActors(self, director):
        project = self._getProject(director)
        if project is None: return
        return project.actors.dereference(director.clerk.db)


    def _getCurrentDocument(self, director):
        session = self._getSession(director)
        current_document = session.current_document
        if not current_document or not current_document.id: return
        return current_document.dereference(director.clerk.db)
    

    def _getFocus(self, director, session=None):
        if not session:
            session = self._getSession(director)
            
        db = director.clerk.db

        if session.categoryselection == 'visuals':
            focus = session.current_document
            if not focus or not focus.id:
                focus = session.current_visual

        elif session.categoryselection == 'actors':
            focus = session.current_actor

        if focus and focus.id:
            focus = focus.dereference(db)

        return focus



def refFromStr(s):
    from dsaw.db._reference import fromString
    return fromString(s)

from gongshuzi.components.Painter import refStrFromRecord


def actor():
    return Actor('gongshuzi')


default_title = 'Gong Shu Zi'
def titleForProjectEditor(project):
    return default_title + ' - ' + project.projectname

from luban.project.Project import Project



def _actorTemplate(name):
    return '''# -*- python -*-

from luban.content import select, load, alert


from luban.components.Actor import Actor as base

class Actor(base):


    class Inventory(base.Inventory):

        import pyre.inventory

        
    def routine1(self, director):
        return


    def routine2(self, director):
        return


def actor():
    return Actor("%s")
''' % name


def _changeActorName(content, oldname, newname):
    lines = content.split('\n')
    i1 = lines.index('def actor():')
    i2 = i1+1
    line2 = lines[i2]
    line2 = line2.strip()
    start = 'return Actor("'
    assert line2.startswith(start)
    end = '")'
    assert line2.endswith(end)
    assert line2[len(start):line2.index(end)] == oldname
    lines[i2] = '    return Actor("%s")' % newname
    return '\n'.join(lines)


# version
__id__ = "$Id$"

# End of file 
